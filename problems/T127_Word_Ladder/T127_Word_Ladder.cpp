#include "headers.h"class Solution { public:  int ladderLength(string beginWord, string endWord, vector<string> &wordList) {    if (wordList.empty()) {      return 0;    }    queue<string> que;    set<string> visted;    que.push(beginWord);    visted.insert(beginWord);    int step = 1;    while (!que.empty()) {      int size = que.size();      for (int i = 0; i < size; i++) {        string currWord = que.front();        que.pop();        bool ret = search(currWord, endWord, que, visted, wordList);        if (ret) {          return step + 1;        }      }      step++;    }    return 0;  }  bool search(string currWord, string endWord, queue<string> que, set<string> visted, vector<string> &wordList) {    int len = currWord.size();    for (int i = 0; i < len; ++i) {      char originChar = currWord.at(i);      for (char j = 'a'; j < 'z'; ++j) {        if (currWord[i] == j) {          continue;        }        currWord[i] = j;        int ct = std::count(wordList.begin(), wordList.end(), currWord);        if (ct) {          if (currWord == endWord) {            return true;          }          if (visted.count(currWord) == 0) {            que.push(currWord);            visted.insert(currWord);          }        }      }      currWord[i] = originChar;    }    return false;  }};TEST(T127_Word_Ladder, testcase1) {//  "hit"//  "cog"//  ["hot","dot","dog","lot","log","cog"]  Solution s;  string beginWord = "hit";  string endWord = "cog";  vector<string> wordList{"hot", "dot", "dog", "lot", "log", "cog"};  s.ladderLength(beginWord, endWord, wordList);}int main(int argc, char **argv) {  ::testing::InitGoogleTest(&argc, argv);  return RUN_ALL_TESTS();}